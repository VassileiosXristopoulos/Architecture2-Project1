.data
CONTROL: .word 0x10000
DATA:    .word 0x10008

P:  .asciiz "P = "
N:  .asciiz "N = "
D:  .asciiz "D = "
T:  .asciiz "T = "
Z:  .asciiz "Z = "
I:  .asciiz "I = "

MAXINT64: .word 0x7FFFFFFFFFFFFFFF
MININT64: .word 0x8000000000000000
MANTISSA_MASK: .word 0x000FFFFFFFFFFFFF
MANTISSA_BIT_53: .word 0x0010000000000000
INFINITY: .word 0x7FF0000000000000

.data
A:	.word 0x04C8195E2ED1912E
	.word 0x1EE697E0360EB0ED
	.word 0x253403F2D677AA37
	.word 0x00F1965A96138C3C
	.word 0x93A1F8278B6D2229
	.word 0x91EE2A9A8AE6AA7E
	.word 0x9F7C9846E73C2987
	.word 0x012BE6239AEBAFDE
	.word 0xB6F9AE98C066CDF0
	.word 0x8473EC766EB129DA
	.word 0x031B19492670A000
	.word 0x4F16872C2F914214
	.word 0xCDA2CA636A9E070F
	.word 0x593356F1DADD81E9
	.word 0xC0E5333C7ADF19F8
	.word 0xD938D5A04C8E20D0
	.word 0x9993CFC4F0EDCF45
	.word 0x511E5A0A475C2FD5
	.word 0xDE45C1D2170DE000
	.word 0xC37FABCA7912EEF1
	.word 0x9E5F7345EB5338B7
	.word 0x54D2A7CB011B0496
	.word 0xEE6FB279C394FA1B
	.word 0x7F6587F61CCD8A2B
	.word 0xDD6E3B292EF54972
	.word 0xA2C9DD0F5CF5BC58
	.word 0x055218FD24B699B0
	.word 0x9E088B4FB6CCE23B
	.word 0xA439E3EE794D1DE9
	.word 0x0657D8F97A5ED130
	.word 0x53C7764979C7347C
	.word 0xE1936D0BCB42E4BF
	.word 0x86E3F125F4B44742
	.word 0x010101D99957D913
	.word 0x44C235499BEBD507
	.word 0x837D6B48FD5925E3
	.word 0x1292C8BA5D495985
	.word 0x4CFB43D1BD3B3287
	.word 0x6293CF7DE25176D9
	.word 0x0D7F3AAB5462CCD5
	.word 0xC7B2DD2AA7D36DCA
	.word 0x741CE8BA9F31475E
	.word 0x8FCB2553C38FBD37
	.word 0xB86BC2114C5DBA1A
	.word 0x282311ECF9A32396
	.word 0x4F4BE490463BA5A2
	.word 0x7897621413946D14
	.word 0xF996751BCF12F8A0
	.word 0x1E70A208D23D467C
	.word 0x2F5DF9B8E6FA18C7
	.word 0x2A1CF9F6882E3874
	.word 0x688A3D80EAB8275F
	.word 0x642F0A4AE1877439
	.word 0x73D50392DBB138F9
	.word 0x030F5ED5DFF5C9B0
	.word 0x2A110FF1492B196F
	.word 0x8D371EA1E67FD6C5
	.word 0x24BD0350DE2BD977
	.word 0x018BEDABBB80E200
	.word 0x57E909E3ABC1D8BF
	.word 0xAA989BB9F5315578
	.word 0xAB8B64C53C150E77
	.word 0xCC843EDC38A1FB92
	.word 0x06F99070341018C0
	.word 0xADE316A001412056
	.word 0x37D63148FA97B249
	.word 0x4A7E515E45331F60
	.word 0xBDF5F6FF26DA646D
	.word 0xD08AA195B55E20BD
	.word 0xE3FF874CB1B800C1
	.word 0x26E292E1EF5B14C5
	.word 0x85395892DAFE04BB
	.word 0x4558DD1134AFBF6F
	.word 0x5D85542A58CA8DE3
	.word 0x1215330D08A2D976
	.word 0x289DB0DD5A1A6F88
	.word 0x4A4933F9BA828112
	.word 0x86359A640BDFFB64
	.word 0x776930E51596748D
	.word 0xF6EEA5991930DE0C
	.word 0x3650C15B6AE22F9B
	.word 0x0CB6E15D0F4D4908
	.word 0xF79635E0FB894B3B
	.word 0x286FE522852C5D63
	.word 0x34250346778E9001
	.word 0x7913B159BFBAA302
	.word 0xEEE997BED7379FAC
	.word 0x724CB47A32C4975B
	.word 0x4492F5FE31A90138
	.word 0x5612D7023C3B351A
	.word 0xFCB50F6769C23BDC
	.word 0x1657CE8CED21D202
	.word 0xEA7F2B2117A155A6
	.word 0x458DEAE92EF1E313
	.word 0x5B451D1BC46403E9
	.word 0xB50006A3F661F26A
	.word 0xEBC8869B06700EDC
	.word 0x447981BB78F774DC
	.word 0xBFD41A38FC17C503
	.word 0xB07C415228E85699
	.word 0x8E7B7700DEC3C086
	.word 0xCA90271C3A62931F
	.word 0xD428A4CC95BEEAD5
	.word 0x785FC85540F69B3F
	.word 0xB7C5B54F086E7FBC
	.word 0xD3E725038D2CF40B
	.word 0xBBF31815D9197F39
	.word 0xEAEBA3207D5492EE
	.word 0x51631C3A12E7262F
	.word 0xD7DFCE102A36E5A6
	.word 0xFA20F99A9F0202EB
	.word 0x925EFE3081EDEE17
	.word 0xC9123960B530D6C1
	.word 0xD8DD7CABA6C6135C
	.word 0x172291683B4EB2D5
	.word 0x83B619DEE2ED8618
	.word 0x159568620612C6EC
	.word 0x8DA3FC47B970800A
	.word 0x4403AC986193E17B
	.word 0x77C57035625F1086
	.word 0xC12FBBA5327FF098
	.word 0x605F2E18E79385CE
	.word 0x593499BAACE414C1
	.word 0xD190BCD068DA6E9A
	.word 0xB8F9D8CDF9E65F7D
	.word 0xD76FF3D4EBCB381A
	.word 0xC584C7F54DC110A7
	.word 0xDD01F1CF58BB6E9E
	.word 0x77D7409EB2D22358
	.word 0x85E6DE81987F3F7D
	.word 0xF588983C119E1464
	.word 0x888EFD2513A2019C
	.word 0x5E057A078367FC6C
	.word 0x6FCA4D84E7F8528C
	.word 0x075C2F10735D79EE
	.word 0x538EE7C68EBA6219
	.word 0x8BDDD7B701A6BBF3
	.word 0x3D0C9F9E497EFA95
	.word 0x00961581321D914D
	.word 0x46079B60BF209873
	.word 0x1401D0AC50171ABE
	.word 0x3E7C658AC19B6461
	.word 0xAE61C9A272F66EF3
	.word 0x5E1633C8CA5D01A1
	.word 0x8E7E2CE43956EE8A
	.word 0xAA50A6EE83607A23
	.word 0x00A011FF6F7FFB56
	.word 0x1B0FA2169DCDBA95
	.word 0x67F2CD40C4348F69
	.word 0x45FF545351E892D3
			    
B:  .space 1200
C:  .space 1200

.text
MAIN:
    ; Counters initialization
    xor R10, R10, R10                   ; This is our counter for (P)
    xor R11, R11, R11                   ; This is our counter for (N)
    xor R12, R12, R12                   ; This is our counter for (D)
    xor R13, R13, R13                   ; This is our counter for (T)
    xor R14, R14, R14                   ; This is our counter for (Z)
    xor R15, R15, R15                   ; This is our counter for (I)

    ld R8, MANTISSA_BIT_53($zero)       ; The explicit 53th bit for the mantissa

    daddi R19, $zero, 0x07FF            ; The mask for getting the exponent. Used elsewhere too

    ld R22, MANTISSA_MASK($zero)        ; Set the mask for getting the mantissa

    xor R23, R23, R23                   ; This is our iterator 

    daddui R24, $zero, 52               ; Shift amount for getting the exponent. Also mantissa size
    
    daddui R16, $zero, 150              ; The number of iterations

    daddui R9, $zero, 63                ; The shift amount to get the sign

__LOOP:
	dsll R6, R23, 3                     ; Compute offset in memory for double word (64 bits)
    ld R1, A(R6)                        ; Load word

    daddui R23, R23, 1                  ; increase iterator

    dsll R25, R1, 1			            ; remove sign to check for zero input

	ld R5, INFINITY($zero)

    beqz R25, __NUMBER_ZERO		    	; check if input number is zero

    and R4, R1, R22                     ; Get mantissa

	beq R25, R5, __HANDLE_INFINITY

    ; Get exponent
    dsrlv R5, R1, R24                   ; shifting 52 bits to the right to get the exponent to the lowest bits
    and R5, R5, R19                     ; and-ing to get only the exponent
  
__COMPUTE_NUMBER:
    daddi R5, R5, -1023                 ; subtract bias
    
    slt R7, R5, $zero                   ; check if exponent is negative
    
    ; zeroing out R25 which is our result register.
    ; if the branch below is taken then the result will be 0.
    ; also we put this instruction so as not to have RAW hazard
    xor R25, R25, R25
    
    bnez R7, __MANIP_LESS_1             ; if exponent negative check if |number| < 0.5 and print  

    slti R7, R5, 63                     ; else check if exponent is less or equal to 62

	or R4, R4, R8                       ; This is the explicit 1 added to the mantissa in IEEE-754 format

    dsrlv R2, R1, R9                    ; Get the sign

    bnez R7, __COMPUTE_INTEGER          ; if it is then go to compute the integer

__CHECK_SIGN_FOR_INFINITY:
    beqz R2, __LOAD_MAXINT              ; else check if sign is zero and if it is load MAXINT

__LOAD_MININT:
    ld R25, MININT64($zero)             ; else load MININT
    daddui R13, R13, 1                  ; increase (T) counter
    j __STORE_RESULT

__LOAD_MAXINT:
    ld R25, MAXINT64($zero)
    daddui R13, R13, 1                  ; increase (T) counter 
    j __STORE_RESULT

__HANDLE_INFINITY:
    daddi R15, R15, 1					; else increase counter for infinity numbers
    j __CHECK_SIGN_FOR_INFINITY         ; and check sign to load the appropriate number

__NUMBER_ZERO:
   daddi R14, R14, 1			        ; increase (Z) counter
   j __STORE_RESULT

__COMPUTE_INTEGER:
    slti R26, R5, 53                     ; check if exponent is less or equal to 52
    daddui R13, R13, 1                   ; increase (T) counter
    beqz R26, __SHIFT_MANTISSA_LEFT      ; if not then we shift the mantissa to the left

__SHIFT_MANTISSA_RIGHT:
    dsub R28, R24, R5                   ; subtract exponent from 52. Thats the amount we need to shift the mantissa to the right
    dsrlv R25, R4, R28
    j __APPLY_SIGN

__SHIFT_MANTISSA_LEFT:
    daddi R28, R5, -52                  ; compute the amount we need to shift the mantissa to the left
    dsllv R25, R4, R28

__APPLY_SIGN:
    beqz R2, __INCREASE_P
	daddui R11, R11, 1					; increase (N) counter
	dsub R25, $zero, R25
	j __STORE_RESULT

__INCREASE_P:
    daddui R10, R10, 1               	; increase (P) counter is sign is 0 
    j __STORE_RESULT

__MANIP_LESS_1:
    slti R21, R5, -1 		            ; check if exp < -1 -- if exp >= -1 then number*2>=1 --> |number| > 0,5
    daddu R12, R12, R21		            ; if so then increase (D) counter
    xori R21, R21, 1                    ; find the complement of R21
    daddu R13, R13, R21                 ; increase (T) counter

__STORE_RESULT:
    sd R25, B(R6)                      	; Storing converted integer
    mtc1 R1, F0                         ; Moving original hexadecimal to a FP register
    cvt.l.d F0, F0                      ; Converting the hexadecimal to integer using cvt
    mfc1 R1, F0                         ; Move converted number to an integer register
    dsub R1, R1, R25                    ; Subtract the converted number from the cvt converted number
    sd R1, C(R6)                       	; Store the result to C

    bne R23, R16, __LOOP
__LOOP_END:
	; Setting I/O
    ld R30, CONTROL($zero)              ; loading the address of control
    ld R31, DATA($zero)                 ; loading the address of data
    daddui R29, $zero, 1                ; mode for unsigned integer output
	daddui R25, $zero, 4				; Mode for printing strings

    daddui R1, $zero, P
    sd R1, 0(R31)
    sd R25, 0(R30)

    sd R10, 0(R31)
    sd R29, 0(R30)

    daddui R1, $zero, N
    sd R1, 0(R31)
    sd R25, 0(R30)

	sd R11, 0(R31)
	sd R29, 0(R30)

	daddui R1, $zero, D
	sd R1, 0(R31)
	sd R25, 0(R30)

	sd R12, 0(R31)
	sd R29, 0(R30)

	daddui R1, $zero, T
	sd R1, 0(R31)
	sd R25, 0(R30)

	sd R13, 0(R31)
	sd R29, 0(R30)

	daddui R1, $zero, Z
	sd R1, 0(R31)
	sd R25, 0(R30)

	sd R14, 0(R31)
	sd R29, 0(R30)

	daddui R1, $zero, I
	sd R1, 0(R31)
	sd R25, 0(R30)

	sd R15, 0(R31)
	sd R29, 0(R30)
__EXIT:
    halt ; Exit program